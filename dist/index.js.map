{"version":3,"file":"index.js","mappings":";;;AAAA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://open-ai-reviewer/webpack/runtime/compat","../webpack://open-ai-reviewer/./lib/main.js"],"sourcesContent":["\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","\"use strict\";\n// import { readFileSync } from \"fs\";\n// import * as core from \"@actions/core\";\n// import OpenAI from \"openai\";\n// import { Octokit } from \"@octokit/rest\";\n// import parseDiff, { Chunk, File } from \"parse-diff\";\n// import minimatch from \"minimatch\";\n// const GITHUB_TOKEN: string = core.getInput(\"GITHUB_TOKEN\");\n// const OPENAI_API_KEY: string = core.getInput(\"OPENAI_API_KEY\");\n// const OPENAI_API_MODEL: string = core.getInput(\"OPENAI_API_MODEL\");\n// const REVIEW_MAX_COMMENTS: string = core.getInput(\"REVIEW_MAX_COMMENTS\");\n// const REVIEW_PROJECT_CONTEXT: string = core.getInput(\"REVIEW_PROJECT_CONTEXT\");\n// const APPROVE_REVIEWS: boolean = core.getInput(\"APPROVE_REVIEWS\") === \"true\";\n// const RESPONSE_TOKENS = 1024;\n// const octokit = new Octokit({ auth: GITHUB_TOKEN });\n// const openai = new OpenAI({\n//   apiKey: OPENAI_API_KEY,\n// });\n// interface PRDetails {\n//   owner: string;\n//   repo: string;\n//   pull_number: number;\n//   title: string;\n//   description: string;\n// }\n// interface AICommentResponse {\n//   file: string;\n//   lineNumber: string;\n//   reviewComment: string;\n// }\n// interface GithubComment {\n//   body: string;\n//   path: string;\n//   line: number;\n// }\n// interface GitHubEvent {\n//   repository: {\n//     full_name: string;\n//     name: string;\n//     owner: { login: string };\n//   };\n//   issue: {\n//     number: number;\n//   };\n// }\n// async function getPRDetails(): Promise<PRDetails> {\n//   core.info(\"Fetching PR details...\");\n//   const eventPayload: GitHubEvent = JSON.parse(\n//     readFileSync(process.env.GITHUB_EVENT_PATH || \"\", \"utf8\")\n//   );\n//   core.info(`Repository: ${eventPayload}`);\n//   const { repository, issue } = eventPayload;\n//   const number = issue.number; // This is your PR number\n//   core.info(`Repository: ${repository.full_name}`);\n//   core.info(`PR Number: ${number}`);\n//   const prResponse = await octokit.pulls.get({\n//     owner: repository.owner.login,\n//     repo: repository.name,\n//     pull_number: number,\n//   });\n//   core.info(`PR details fetched for PR #${number}`);\n//   return {\n//     owner: repository.owner.login,\n//     repo: repository.name,\n//     pull_number: number,\n//     title: prResponse.data.title ?? \"\",\n//     description: prResponse.data.body ?? \"\",\n//   };\n// }\n// async function getDiff(\n//   owner: string,\n//   repo: string,\n//   pull_number: number\n// ): Promise<string | null> {\n//   core.info(`Fetching diff for PR #${pull_number}...`);\n//   const response = await octokit.pulls.get({\n//     owner,\n//     repo,\n//     pull_number,\n//     mediaType: { format: \"diff\" },\n//   });\n//   // @ts-expect-error - response.data is a string\n//   return response.data;\n// }\n// async function analyzeCode(\n//   changedFiles: File[],\n//   prDetails: PRDetails\n// ): Promise<Array<GithubComment>> {\n//   core.info(\"Analyzing code...\");\n//   core.info(JSON.stringify(prDetails, null, 2));\n//   core.info(\"printing REVIEW_PROJECT_CONTEXT\");\n//   core.info(REVIEW_PROJECT_CONTEXT);\n//   core.info(JSON.stringify(changedFiles, null, 2));\n//   core.info(\"STARTING PROMPT\");\n//   const prompt = createPrompt(changedFiles, prDetails);\n//   core.info(prompt);\n//   const aiResponse = await getAIResponse(prompt);\n//   core.info(JSON.stringify(aiResponse, null, 2));\n//   const comments: Array<GithubComment> = [];\n//   if (aiResponse) {\n//     const newComments = createComments(changedFiles, aiResponse);\n//     if (newComments) {\n//       comments.push(...newComments);\n//     }\n//   }\n//   core.info(`Analysis complete. Generated ${comments.length} comments.`);\n//   return comments;\n// }\n// function createPrompt(changedFiles: File[], prDetails: PRDetails): string {\n//   core.info(\"Creating prompt for AI...\");\n//   const problemOutline = `Your task is to review pull requests (PR). Instructions:\n// - Provide the response in following JSON format:  {\"comments\": [{\"file\": <file name>,  \"lineNumber\":  <line_number>, \"reviewComment\": \"<review comment>\"}]}\n// - DO NOT give positive comments or compliments.\n// - DO NOT give advice on renaming variable names or writing more descriptive variables.\n// - Provide comments and suggestions ONLY if there is something to improve, otherwise return an empty array.\n// - Provide at most ${REVIEW_MAX_COMMENTS} comments. It's up to you how to decide which comments to include.\n// - Write the comment in GitHub Markdown format.\n// - Use the given description only for the overall context and only comment the code.\n// ${\n//   REVIEW_PROJECT_CONTEXT\n//     ? `- Additional context regarding this PR's project: ${REVIEW_PROJECT_CONTEXT}`\n//     : \"\"\n// }\n// - IMPORTANT: Suggest adding comments only for complex logic or non-obvious business rules that require explanation.\n// - IMPORTANT: Evaluate the entire diff in the PR before adding any comments.\n// Pull request title: ${prDetails.title}\n// TAKE A DEEP BREATH AND WORK ON THIS THIS PROBLEM STEP-BY-STEP.\n// `;\n//   const diffChunksPrompt = new Array();\n//   for (const file of changedFiles) {\n//     if (file.to === \"/dev/null\") continue; // Ignore deleted files\n//     for (const chunk of file.chunks) {\n//       diffChunksPrompt.push(createPromptForDiffChunk(file, chunk));\n//     }\n//   }\n//   core.info(\"Prompt created successfully.\");\n//   return `${problemOutline}\\n ${diffChunksPrompt.join(\"\\n\")}`;\n// }\n// function createPromptForDiffChunk(file: File, chunk: Chunk): string {\n//   return `\\n\n//   Review the following code diff in the file \"${file.to}\". Git diff to review:\n//   \\`\\`\\`diff\n//   ${chunk.content}\n//   ${chunk.changes\n//     // @ts-expect-error - ln and ln2 exists where needed\n//     .map((c) => `${c.ln ? c.ln : c.ln2} ${c.content}`)\n//     .join(\"\\n\")}\n//   \\`\\`\\`\n//   `;\n// }\n// async function getAIResponse(\n//   prompt: string\n// ): Promise<Array<AICommentResponse>> {\n//   core.info(\"Sending request to OpenAI API...\");\n//   const queryConfig = {\n//     model: OPENAI_API_MODEL,\n//     temperature: 0.2,\n//     max_tokens: RESPONSE_TOKENS,\n//     top_p: 1,\n//     frequency_penalty: 0,\n//     presence_penalty: 0,\n//     response_format: {\n//       type: \"json_object\",\n//     } as const,\n//   };\n//   try {\n//     const response = await openai.chat.completions.create({\n//       ...queryConfig,\n//       messages: [\n//         {\n//           role: \"system\",\n//           content: prompt,\n//         },\n//       ],\n//     });\n//     if (!response.choices || response.choices.length === 0) {\n//       throw new Error(\"OpenAI API returned an invalid response\");\n//     }\n//     core.info(\"Received response from OpenAI API.\");\n//     const res = response.choices[0].message?.content?.trim() || \"{}\";\n//     // Remove any markdown formatting and ensure valid JSON\n//     const jsonString = res.replace(/^```json\\s*|\\s*```$/g, \"\").trim();\n//     try {\n//       let data = JSON.parse(jsonString);\n//       if (!Array.isArray(data?.comments)) {\n//         throw new Error(\"Invalid response from OpenAI API\");\n//       }\n//       return data.comments;\n//     } catch (parseError) {\n//       core.error(`Failed to parse JSON: ${jsonString}`);\n//       core.error(`Parse error: ${parseError}`);\n//       throw parseError;\n//     }\n//   } catch (error: any) {\n//     core.error(\"Error Message:\", error?.message || error);\n//     if (error?.response) {\n//       core.error(\"Response Data:\", error.response.data);\n//       core.error(\"Response Status:\", error.response.status);\n//       core.error(\"Response Headers:\", error.response.headers);\n//     }\n//     if (error?.config) {\n//       core.error(\"Config:\", error.config);\n//     }\n//     core.setFailed(`OpenAI API request failed: ${error.message}`);\n//     throw error;\n//   }\n// }\n// function createComments(\n//   changedFiles: File[],\n//   aiResponses: Array<AICommentResponse>\n// ): Array<GithubComment> {\n//   core.info(\"Creating GitHub comments from AI responses...\");\n//   return aiResponses\n//     .flatMap((aiResponse) => {\n//       const file = changedFiles.find((file) => file.to === aiResponse.file);\n//       return {\n//         body: aiResponse.reviewComment,\n//         path: file?.to ?? \"\",\n//         line: Number(aiResponse.lineNumber),\n//       };\n//     })\n//     .filter((comments) => comments.path !== \"\");\n// }\n// async function createReviewComment(\n//   owner: string,\n//   repo: string,\n//   pull_number: number,\n//   comments: Array<GithubComment>\n// ): Promise<void> {\n//   core.info(`Creating review comment for PR #${pull_number}...`);\n//   await octokit.pulls.createReview({\n//     owner,\n//     repo,\n//     pull_number,\n//     comments,\n//     event: APPROVE_REVIEWS ? \"APPROVE\" : \"COMMENT\",\n//   });\n//   core.info(\n//     `Review ${APPROVE_REVIEWS ? \"approved\" : \"commented\"} successfully.`\n//   );\n// }\n// async function hasExistingReview(\n//   owner: string,\n//   repo: string,\n//   pull_number: number\n// ): Promise<boolean> {\n//   const reviews = await octokit.pulls.listReviews({\n//     owner,\n//     repo,\n//     pull_number,\n//   });\n//   return reviews.data.length > 0;\n// }\n// async function main() {\n//   core.info(`TEST:1 fix the event type to comment`);\n//   try {\n//     core.info(\"Starting AI code review process...\");\n//     const prDetails = await getPRDetails();\n//     core.info(JSON.stringify(prDetails, null, 2));\n//     core.info(\"PR DETAILS FETCHED\");\n//     let diff: string | null;\n//     const eventData = JSON.parse(\n//       readFileSync(process.env.GITHUB_EVENT_PATH ?? \"\", \"utf8\")\n//     );\n//     core.info(JSON.stringify(eventData, null, 2));\n//     core.info(\"EVENT DATA FETCHED\");\n//     core.info(`Processing ${eventData.action} event...`);\n//     const existingReview = await hasExistingReview(\n//       prDetails.owner,\n//       prDetails.repo,\n//       prDetails.pull_number\n//     );\n//     if (\n//       eventData.action === \"opened\" ||\n//       (eventData.action === \"synchronize\" && !existingReview)\n//     ) {\n//       diff = await getDiff(\n//         prDetails.owner,\n//         prDetails.repo,\n//         prDetails.pull_number\n//       );\n//     } else if (eventData.action === \"synchronize\" && existingReview) {\n//       // Get the PR details to get the correct base and head\n//       const prResponse = await octokit.pulls.get({\n//         owner: prDetails.owner,\n//         repo: prDetails.repo,\n//         pull_number: prDetails.pull_number,\n//       });\n//       core.info(\n//         `Comparing PR base -> head: ${prResponse.data.base.sha} -> ${prResponse.data.head.sha}`\n//       );\n//       const response = await octokit.repos.compareCommits({\n//         headers: {\n//           accept: \"application/vnd.github.v3.diff\",\n//         },\n//         owner: prDetails.owner,\n//         repo: prDetails.repo,\n//         base: prResponse.data.base.sha,\n//         head: prResponse.data.head.sha,\n//       });\n//       diff = String(response.data);\n//     } else if (eventData.action === \"created\") {\n//       const comment = eventData.comment.body;\n//       core.info(`Comment: ${comment}`);\n//       diff = await getDiff(\n//         prDetails.owner,\n//         prDetails.repo,\n//         prDetails.pull_number\n//       );\n//       core.info(`diff: ${diff}`);\n//     } else {\n//       core.info(`Unsupported event: ${process.env.GITHUB_EVENT_NAME}`);\n//       return;\n//     }\n//     if (!diff) {\n//       core.info(\"No diff found\");\n//       return;\n//     }\n//     const changedFiles = parseDiff(diff);\n//     core.info(`Found ${changedFiles.length} changed files.`);\n//     const excludePatterns = core\n//       .getInput(\"exclude\")\n//       .split(\",\")\n//       .map((s) => s.trim());\n//     const filteredDiff = changedFiles.filter((file) => {\n//       return !excludePatterns.some((pattern) =>\n//         minimatch(file.to ?? \"\", pattern)\n//       );\n//     });\n//     core.info(`After filtering, ${filteredDiff.length} files remain.`);\n//     const comments = await analyzeCode(filteredDiff, prDetails);\n//     if (APPROVE_REVIEWS || comments.length > 0) {\n//       await createReviewComment(\n//         prDetails.owner,\n//         prDetails.repo,\n//         prDetails.pull_number,\n//         comments\n//       );\n//     } else {\n//       core.info(\"No comments to post.\");\n//     }\n//     core.info(\"AI code review process completed successfully.\");\n//   } catch (error: any) {\n//     core.error(\"Error:\", error);\n//     core.setFailed(`Action failed: ${error.message}`);\n//     process.exit(1); // This line ensures the GitHub action fails\n//   }\n// }\n// core.info(\"Starting AI code review action...\");\n// main().catch((error) => {\n//   core.error(\"Unhandled error in main function:\", error);\n//   core.setFailed(\n//     `Unhandled error in main function: ${(error as Error).message}`\n//   );\n//   process.exit(1);\n// });\n"],"names":[],"sourceRoot":""}